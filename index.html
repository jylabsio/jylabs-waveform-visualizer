<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>jylabs — Waveform</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=Geist+Mono:wght@300;400;500&family=Geist:wght@300;400;500;700&display=swap');

:root {
  --white: #ffffff; --black: #0a0a0a;
  --gray-100: #f5f5f5; --gray-200: #e8e8e8; --gray-300: #d0d0d0;
  --gray-500: #888888; --gray-700: #444444; --border: #e0e0e0;
  --mono: 'Geist Mono', monospace;
  --sans: 'Geist', sans-serif;
  --serif: 'Instrument Serif', serif;
}
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html { font-size: 16px; }
body { background: var(--white); color: var(--black); font-family: var(--sans); min-height: 100vh; -webkit-font-smoothing: antialiased; }

/* Header */
header { position: fixed; top: 0; left: 0; right: 0; height: 56px; display: flex; align-items: center; justify-content: space-between; padding: 0 32px; background: rgba(255,255,255,0.94); backdrop-filter: blur(12px); border-bottom: 1px solid var(--border); z-index: 100; }
.logo-wrap { display: flex; align-items: baseline; gap: 10px; }
.logo-name { font-family: var(--mono); font-size: 0.85rem; font-weight: 500; }
.logo-dot { width: 5px; height: 5px; border-radius: 50%; background: var(--black); margin-bottom: 2px; flex-shrink: 0; }
.logo-product { font-family: var(--mono); font-size: 0.72rem; font-weight: 300; color: var(--gray-500); letter-spacing: 0.08em; text-transform: uppercase; }
.header-right { display: flex; align-items: center; gap: 8px; }
.nav-tag { font-family: var(--mono); font-size: 0.62rem; letter-spacing: 0.12em; text-transform: uppercase; color: var(--gray-500); padding: 4px 10px; border: 1px solid var(--border); border-radius: 2px; }
.ver-tag { font-family: var(--mono); font-size: 0.62rem; letter-spacing: 0.1em; color: var(--gray-300); padding: 4px 10px; border: 1px solid var(--gray-200); border-radius: 2px; }

/* Page */
.page { padding-top: 56px; min-height: 100vh; display: flex; flex-direction: column; }

/* Upload */
#uploadSection { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 80px 40px; }
.hero-eyebrow { font-family: var(--mono); font-size: 0.65rem; letter-spacing: 0.2em; text-transform: uppercase; color: var(--gray-500); margin-bottom: 20px; display: flex; align-items: center; gap: 10px; }
.hero-eyebrow::before, .hero-eyebrow::after { content: ''; display: block; width: 32px; height: 1px; background: var(--gray-300); }
.hero-title { font-family: var(--serif); font-size: clamp(2.6rem, 5.5vw, 4.5rem); font-weight: 400; line-height: 1.07; letter-spacing: -0.02em; text-align: center; margin-bottom: 14px; }
.hero-title em { font-style: italic; color: var(--gray-700); }
.hero-sub { font-family: var(--sans); font-size: 0.88rem; font-weight: 300; color: var(--gray-500); text-align: center; margin-bottom: 52px; }
.drop-zone { width: 100%; max-width: 640px; border: 1.5px dashed var(--gray-300); border-radius: 6px; padding: 52px 40px; text-align: center; cursor: pointer; transition: all 0.22s; background: var(--white); }
.drop-zone:hover, .drop-zone.drag-over { border-color: var(--black); background: var(--gray-100); }
.drop-icon { width: 40px; height: 40px; margin: 0 auto 16px; display: flex; align-items: center; justify-content: center; }
.drop-icon svg { width: 34px; height: 34px; stroke: var(--black); stroke-width: 1.3; }
.drop-title { font-family: var(--sans); font-size: 0.95rem; font-weight: 500; margin-bottom: 5px; }
.drop-sub { font-family: var(--mono); font-size: 0.68rem; color: var(--gray-500); letter-spacing: 0.04em; margin-bottom: 20px; }
.format-pills { display: flex; gap: 6px; justify-content: center; flex-wrap: wrap; }
.pill { font-family: var(--mono); font-size: 0.58rem; letter-spacing: 0.1em; padding: 3px 9px; border-radius: 2px; border: 1px solid var(--border); color: var(--gray-500); }
.pill.v { border-color: var(--gray-300); color: var(--gray-700); }
#fileInput { display: none; }

/* Loading */
.loading-wrap { width: 100%; max-width: 640px; margin-top: 20px; display: none; }
.loading-wrap.active { display: block; }
.loading-bar { height: 2px; background: var(--gray-200); border-radius: 1px; overflow: hidden; }
.loading-fill { height: 100%; background: linear-gradient(90deg, var(--gray-300), var(--black), var(--gray-300)); background-size: 200% 100%; animation: shimmer 1.1s linear infinite; }
@keyframes shimmer { 0%{background-position:200% 0} 100%{background-position:-200% 0} }
.loading-txt { font-family: var(--mono); font-size: 0.63rem; letter-spacing: 0.1em; color: var(--gray-500); text-align: center; margin-top: 10px; }

/* Workspace */
#workspace { display: none; flex: 1; flex-direction: column; }
@keyframes fadeIn { from{opacity:0;transform:translateY(10px)} to{opacity:1;transform:translateY(0)} }
#workspace.visible { display: flex; animation: fadeIn 0.3s ease forwards; }

/* File bar */
.file-bar { border-bottom: 1px solid var(--border); padding: 0 32px; height: 44px; display: flex; align-items: center; gap: 14px; background: var(--gray-100); }
.file-indicator { width: 6px; height: 6px; border-radius: 50%; background: var(--black); animation: blink 2.5s ease-in-out infinite; flex-shrink: 0; }
@keyframes blink { 0%,100%{opacity:1}50%{opacity:0.25} }
.file-name-text { font-family: var(--mono); font-size: 0.72rem; color: var(--black); flex: 1; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.file-type-tag { font-family: var(--mono); font-size: 0.58rem; letter-spacing: 0.12em; padding: 2px 8px; border-radius: 2px; flex-shrink: 0; }
.file-type-tag.video { background: var(--black); color: var(--white); }
.file-type-tag.audio { background: var(--gray-200); color: var(--black); }
.file-dur { font-family: var(--mono); font-size: 0.68rem; color: var(--gray-500); flex-shrink: 0; }

/* Canvas */
.canvas-section { position: relative; aspect-ratio: 16/9; overflow: hidden; flex-shrink: 0;
  background-image: linear-gradient(45deg,#1a1a1a 25%,transparent 25%),linear-gradient(-45deg,#1a1a1a 25%,transparent 25%),linear-gradient(45deg,transparent 75%,#1a1a1a 75%),linear-gradient(-45deg,transparent 75%,#1a1a1a 75%);
  background-size:16px 16px; background-position:0 0,0 8px,8px -8px,-8px 0; background-color:#111; }
.canvas-section.has-bg { background: var(--black); }
#bgCanvas, #waveCanvas { position: absolute; inset: 0; width: 100%; height: 100%; }
#bgCanvas{z-index:1} #waveCanvas{z-index:2}
.canvas-ui { position: absolute; inset: 0; z-index: 3; pointer-events: none; display: flex; align-items: flex-end; justify-content: space-between; padding: 18px 22px; }
.canvas-label { font-family: var(--mono); font-size: 0.58rem; letter-spacing: 0.14em; color: rgba(255,255,255,0.22); text-transform: uppercase; }
.canvas-brand { font-family: var(--mono); font-size: 0.58rem; letter-spacing: 0.1em; color: rgba(255,255,255,0.15); }

/* Controls panel */
.controls-panel { border-top: 1px solid var(--border); display: grid; grid-template-columns: 1fr 300px; }
.controls-left { padding: 26px 32px; border-right: 1px solid var(--border); }
.controls-right { padding: 26px 26px; display: flex; flex-direction: column; gap: 14px; }

/* Playback */
.playback-row { display: flex; align-items: center; gap: 14px; margin-bottom: 26px; }
.play-btn { width: 42px; height: 42px; border-radius: 50%; background: var(--black); border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: background 0.15s; flex-shrink: 0; }
.play-btn:hover { background: var(--gray-700); }
.play-btn:disabled { opacity: 0.3; cursor: not-allowed; }
.play-btn svg { width: 18px; height: 18px; fill: var(--white); }
.progress-track { flex: 1; height: 2px; background: var(--gray-200); border-radius: 1px; cursor: pointer; }
.progress-fill { height: 100%; background: var(--black); border-radius: 1px; width: 0%; pointer-events: none; transition: width 0.08s linear; }
.time-txt { font-family: var(--mono); font-size: 0.67rem; color: var(--gray-500); white-space: nowrap; min-width: 80px; text-align: right; }

/* Style tabs */
.ctrl-label { font-family: var(--mono); font-size: 0.58rem; letter-spacing: 0.18em; text-transform: uppercase; color: var(--gray-500); margin-bottom: 10px; }
.style-tabs { display: flex; border: 1px solid var(--border); border-radius: 4px; overflow: hidden; margin-bottom: 22px; }
.style-tab { flex: 1; padding: 9px 6px; background: var(--white); border: none; border-right: 1px solid var(--border); font-family: var(--mono); font-size: 0.6rem; letter-spacing: 0.06em; color: var(--gray-500); cursor: pointer; transition: all 0.14s; text-align: center; }
.style-tab:last-child { border-right: none; }
.style-tab:hover { background: var(--gray-100); color: var(--black); }
.style-tab.active { background: var(--black); color: var(--white); }

/* Params */
.params-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 18px 24px; }
.param-label { font-family: var(--mono); font-size: 0.58rem; letter-spacing: 0.14em; text-transform: uppercase; color: var(--gray-500); margin-bottom: 8px; display: flex; justify-content: space-between; }
.param-val { color: var(--black); font-weight: 500; }
input[type="range"] { width: 100%; -webkit-appearance: none; height: 2px; background: var(--gray-200); border-radius: 1px; outline: none; cursor: pointer; }
input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; border-radius: 50%; background: var(--black); cursor: pointer; border: 2px solid var(--white); box-shadow: 0 0 0 1px var(--black); }

/* Colors */
.color-row { display: flex; gap: 10px; margin-top: 20px; }
.color-group { flex: 1; }
.color-group label { font-family: var(--mono); font-size: 0.58rem; letter-spacing: 0.14em; text-transform: uppercase; color: var(--gray-500); display: block; margin-bottom: 7px; }
input[type="color"] { width: 100%; height: 34px; border: 1px solid var(--border); border-radius: 3px; background: var(--white); cursor: pointer; padding: 2px; }
select.ctrl-select { width: 100%; height: 34px; background: var(--white); border: 1px solid var(--border); color: var(--black); padding: 0 10px; border-radius: 3px; font-family: var(--mono); font-size: 0.63rem; cursor: pointer; outline: none; -webkit-appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6' viewBox='0 0 10 6'%3E%3Cpath d='M0 0l5 6 5-6z' fill='%23888'/%3E%3C/svg%3E");
  background-repeat: no-repeat; background-position: right 10px center; }

/* Toggle */
.toggle-item { display: flex; align-items: center; justify-content: space-between; padding: 14px 0; border-top: 1px solid var(--border); margin-top: 18px; }
.toggle-title { font-family: var(--sans); font-size: 0.8rem; font-weight: 500; margin-bottom: 2px; }
.toggle-sub { font-family: var(--mono); font-size: 0.6rem; color: var(--gray-500); }
.switch { position: relative; width: 40px; height: 22px; flex-shrink: 0; }
.switch input { opacity: 0; width: 0; height: 0; }
.switch-track { position: absolute; inset: 0; background: var(--gray-200); border-radius: 11px; cursor: pointer; transition: background 0.2s; border: 1px solid var(--border); }
.switch-track::before { content: ''; position: absolute; width: 16px; height: 16px; left: 2px; top: 2px; background: var(--white); border-radius: 50%; transition: transform 0.2s; box-shadow: 0 1px 3px rgba(0,0,0,0.12); }
.switch input:checked + .switch-track { background: var(--black); border-color: var(--black); }
.switch input:checked + .switch-track::before { transform: translateX(18px); }

/* Right panel */
.section-head { font-family: var(--mono); font-size: 0.58rem; letter-spacing: 0.18em; text-transform: uppercase; color: var(--gray-500); padding-bottom: 12px; border-bottom: 1px solid var(--border); margin-bottom: 12px; }
.info-note { display: none; padding: 11px 13px; background: var(--gray-100); border-radius: 3px; border-left: 2px solid var(--black); font-family: var(--mono); font-size: 0.61rem; color: var(--gray-700); line-height: 1.8; margin-bottom: 10px; }
.info-note.show { display: block; }
.info-note strong { color: var(--black); }

/* Status bar — recording + converting share this */
.status-bar { display: none; flex-direction: column; gap: 6px; padding: 12px 13px; background: var(--black); border-radius: 3px; }
.status-bar.active { display: flex; }
.status-row { display: flex; align-items: center; gap: 10px; }
.status-dot { width: 7px; height: 7px; border-radius: 50%; background: #fff; animation: recpulse 1s ease-in-out infinite; flex-shrink: 0; }
@keyframes recpulse { 0%,100%{opacity:1}50%{opacity:0.2} }
.status-text { font-family: var(--mono); font-size: 0.64rem; color: var(--white); flex: 1; }
.status-time { font-family: var(--mono); font-size: 0.64rem; color: rgba(255,255,255,0.45); }
.status-progress { height: 2px; background: rgba(255,255,255,0.15); border-radius: 1px; overflow: hidden; }
.status-progress-fill { height: 100%; background: rgba(255,255,255,0.6); border-radius: 1px; width: 0%; transition: width 0.3s ease; }

/* Buttons */
.btn-group { display: flex; flex-direction: column; gap: 8px; margin-top: auto; }
.btn { width: 100%; padding: 11px 16px; border-radius: 3px; font-family: var(--mono); font-size: 0.68rem; letter-spacing: 0.07em; cursor: pointer; transition: all 0.15s; border: none; text-align: center; }
.btn-primary { background: var(--black); color: var(--white); font-weight: 500; }
.btn-primary:hover { background: var(--gray-700); }
.btn-secondary { background: var(--white); color: var(--black); border: 1px solid var(--border); }
.btn-secondary:hover { background: var(--gray-100); }
.btn-ghost { background: transparent; color: var(--gray-500); border: 1px solid var(--border); }
.btn-ghost:hover { color: var(--black); }
.btn-stop { background: var(--gray-700); color: var(--white); }
.btn-stop:hover { background: var(--black); }
.btn:disabled { opacity: 0.35; cursor: not-allowed; pointer-events: none; }

/* Toast */
.toast { position: fixed; bottom: 28px; left: 50%; transform: translateX(-50%); background: var(--black); color: var(--white); padding: 15px 22px; border-radius: 4px; font-family: var(--mono); font-size: 0.65rem; line-height: 1.9; z-index: 9999; max-width: 480px; text-align: center; box-shadow: 0 8px 32px rgba(0,0,0,0.18); transition: opacity 0.5s; }

/* Footer */
footer { border-top: 1px solid var(--border); padding: 14px 32px; display: flex; align-items: center; justify-content: space-between; }
.footer-brand { font-family: var(--mono); font-size: 0.62rem; color: var(--gray-500); }
.footer-ver { font-family: var(--mono); font-size: 0.62rem; color: var(--gray-300); margin-left: 10px; }
.footer-note { font-family: var(--mono); font-size: 0.58rem; color: var(--gray-300); }
</style>
</head>
<body>

<header>
  <div class="logo-wrap">
    <span class="logo-name">jylabs.io</span>
    <div class="logo-dot"></div>
    <span class="logo-product">Waveform</span>
  </div>
  <div class="header-right">
    <span class="nav-tag">Audio Visualizer</span>
    <span class="ver-tag" id="verTag">V1.4</span>
  </div>
</header>

<div class="page">

  <div id="uploadSection">
    <div class="hero-eyebrow">Audio Tool</div>
    <h1 class="hero-title">Turn sound into<br><em>visual motion</em></h1>
    <p class="hero-sub">Drop an audio or video file — exports as MP4, ready for Premiere.</p>
    <div class="drop-zone" id="uploadZone">
      <div class="drop-icon">
        <svg viewBox="0 0 24 24" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path d="M9 19V6l12-3v13"/><circle cx="6" cy="18" r="3"/><circle cx="18" cy="15" r="3"/>
        </svg>
      </div>
      <div class="drop-title">Drop your file here</div>
      <div class="drop-sub">or click to browse &mdash; <span style="color:var(--gray-300)">max 200 MB</span></div>
      <div class="format-pills">
        <span class="pill v">MP4</span><span class="pill v">MOV</span><span class="pill v">WEBM</span>
        <span class="pill">MP3</span><span class="pill">WAV</span><span class="pill">M4A</span><span class="pill">OGG</span>
      </div>
      <input type="file" id="fileInput" accept="audio/*,video/*">
    </div>
    <div class="loading-wrap" id="loadingWrap">
      <div class="loading-bar"><div class="loading-fill"></div></div>
      <div class="loading-txt" id="loadingTxt">Loading…</div>
    </div>
  </div>

  <div id="workspace">
    <div class="file-bar">
      <div class="file-indicator"></div>
      <div class="file-name-text" id="fileName">—</div>
      <span class="file-type-tag audio" id="fileTypeBadge">AUDIO</span>
      <div class="file-dur" id="fileDuration">0:00</div>
    </div>

    <div class="canvas-section has-bg" id="canvasWrap">
      <canvas id="bgCanvas"></canvas>
      <canvas id="waveCanvas"></canvas>
      <div class="canvas-ui">
        <span class="canvas-label" id="canvasLabel"></span>
        <span class="canvas-brand">jylabs.io</span>
      </div>
    </div>

    <div class="controls-panel">
      <div class="controls-left">
        <div class="playback-row">
          <button class="play-btn" id="playBtn">
            <svg viewBox="0 0 24 24" id="playIcon"><path d="M8 5v14l11-7z"/></svg>
          </button>
          <div class="progress-track" id="progressWrap">
            <div class="progress-fill" id="progressBar"></div>
          </div>
          <div class="time-txt"><span id="currentTime">0:00</span> / <span id="totalTime">0:00</span></div>
        </div>

        <div class="ctrl-label">Waveform Style</div>
        <div class="style-tabs">
          <button class="style-tab active" data-style="bars">Bars</button>
          <button class="style-tab" data-style="mirror">Mirror</button>
          <button class="style-tab" data-style="line">Line</button>
          <button class="style-tab" data-style="circle">Radial</button>
        </div>

        <div class="params-grid">
          <div>
            <div class="param-label">Bar Width <span class="param-val" id="barWidthVal">4</span></div>
            <input type="range" id="barWidth" min="1" max="16" value="4">
          </div>
          <div>
            <div class="param-label">Sensitivity <span class="param-val" id="sensitivityVal">1.5</span></div>
            <input type="range" id="sensitivity" min="0.5" max="4" step="0.1" value="1.5">
          </div>
        </div>

        <div class="color-row">
          <div class="color-group">
            <label>Wave Color</label>
            <input type="color" id="waveColor" value="#ffffff">
          </div>
          <div class="color-group" id="bgColorGroup">
            <label>Background</label>
            <input type="color" id="bgColor" value="#0a0a0a">
          </div>
          <div class="color-group" id="bgStyleGroup">
            <label>BG Style</label>
            <select id="bgStyle" class="ctrl-select">
              <option value="solid">Solid</option>
              <option value="gradient">Gradient</option>
              <option value="radial">Radial</option>
            </select>
          </div>
        </div>

        <div class="toggle-item">
          <div>
            <div class="toggle-title">Transparent Background</div>
            <div class="toggle-sub">Exports WebM with alpha (Premiere / AE)</div>
          </div>
          <label class="switch">
            <input type="checkbox" id="transparentToggle">
            <span class="switch-track"></span>
          </label>
        </div>
      </div>

      <div class="controls-right">
        <div>
          <div class="section-head">Export</div>
          <div class="info-note" id="videoNote">
            <strong>Video file loaded.</strong><br>Audio extracted automatically.
          </div>
          <div class="info-note" id="transTip">
            <strong>Transparent mode.</strong><br>
            Exports WebM with alpha channel.<br>
            Premiere → blend: Normal<br>
            After Effects → Interpret Alpha: Straight
          </div>
          <div class="info-note" id="ffmpegNote" style="display:none;">
            <strong>First export loads FFmpeg.</strong><br>
            ~30 MB downloads once, then cached. Subsequent exports are instant.
          </div>
        </div>

        <!-- Shared status bar for recording + converting -->
        <div class="status-bar" id="statusBar">
          <div class="status-row">
            <div class="status-dot"></div>
            <div class="status-text" id="statusText">Rendering…</div>
            <div class="status-time" id="statusTime">0:00</div>
          </div>
          <div class="status-progress">
            <div class="status-progress-fill" id="statusFill"></div>
          </div>
        </div>

        <div class="btn-group">
          <button class="btn btn-primary" id="exportVideoBtn">Export MP4</button>
          <button class="btn btn-secondary" id="exportPngBtn">Export PNG Frame</button>
          <button class="btn btn-ghost" id="resetBtn">Load New File</button>
        </div>
      </div>
    </div>
  </div>

  <footer>
    <span class="footer-brand">jylabs.io — Waveform <span class="footer-ver" id="footerVer">V1.4</span></span>
    <span class="footer-note">Runs locally in your browser. No uploads.</span>
  </footer>
</div>

<script>
'use strict';

// ─── Version ──────────────────────────────────────────────────────────────────
const VERSION = 'V1.4';
document.getElementById('verTag').textContent    = VERSION;
document.getElementById('footerVer').textContent = VERSION;

// ─── FFmpeg WASM — loaded lazily on first export ──────────────────────────────
// Uses @ffmpeg/ffmpeg v0.12 ESM build from CDN
let ffmpegReady = false;
let ffmpegLoading = false;
let ffmpegInstance = null;

async function ensureFFmpeg() {
  if (ffmpegReady) return true;
  if (ffmpegLoading) {
    // Wait until it finishes loading
    while (ffmpegLoading) await new Promise(r => setTimeout(r, 100));
    return ffmpegReady;
  }
  ffmpegLoading = true;
  setStatus('Loading FFmpeg (~30 MB, one time)…', '', 0);

  try {
    // Dynamically import FFmpeg ESM from CDN
    const { FFmpeg } = await import('https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.10/dist/esm/index.js');
    const { fetchFile, toBlobURL } = await import('https://cdn.jsdelivr.net/npm/@ffmpeg/util@0.12.1/dist/esm/index.js');

    // Store fetchFile globally for use in conversion
    window._ffetchFile = fetchFile;

    const baseURL = 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.6/dist/esm';
    ffmpegInstance = new FFmpeg();

    // Log FFmpeg progress
    ffmpegInstance.on('progress', ({ progress }) => {
      const pct = Math.round(progress * 100);
      setStatus('Converting to MP4…', `${pct}%`, progress);
    });

    await ffmpegInstance.load({
      coreURL:   await toBlobURL(`${baseURL}/ffmpeg-core.js`,   'text/javascript'),
      wasmURL:   await toBlobURL(`${baseURL}/ffmpeg-core.wasm`, 'application/wasm'),
    });

    ffmpegReady  = true;
    ffmpegLoading = false;
    return true;
  } catch(e) {
    ffmpegLoading = false;
    console.error('FFmpeg load failed:', e);
    return false;
  }
}

// ─── State ────────────────────────────────────────────────────────────────────
let audioCtx, analyser, source, audioBuffer;
let isPlaying = false, startTime = 0, pauseOffset = 0, animFrame;
let waveStyle = 'bars';
let waveDataFull = null;
let freqData     = null;
let isTransparent = false, isRecording = false, isConverting = false;
let mediaRecorder = null, recordedChunks = [];
let recAF = null, recStartWallTime = 0;
let recAudioCtx = null, recAnalyser = null, recSource = null, recFreqData = null;
let exportCanvas = null, exportCtx = null;
let isVideoSource = false;

const $ = id => document.getElementById(id);

// ─── Upload ───────────────────────────────────────────────────────────────────
const uploadZone = $('uploadZone'), fileInput = $('fileInput');
uploadZone.addEventListener('click', () => fileInput.click());
uploadZone.addEventListener('dragover', e => { e.preventDefault(); uploadZone.classList.add('drag-over'); });
uploadZone.addEventListener('dragleave', () => uploadZone.classList.remove('drag-over'));
uploadZone.addEventListener('drop', e => {
  e.preventDefault(); uploadZone.classList.remove('drag-over');
  const f = e.dataTransfer.files[0]; if (f) loadFile(f);
});
fileInput.addEventListener('change', () => { if (fileInput.files[0]) loadFile(fileInput.files[0]); });

async function loadFile(file) {
  const isVideo = file.type.startsWith('video/') || /\.(mp4|mov|webm|avi|mkv)$/i.test(file.name);
  isVideoSource = isVideo;

  // Size limit
  const MAX_MB = 200, MAX_B = MAX_MB * 1024 * 1024;
  if (file.size > MAX_B) {
    const fileMB = (file.size / 1024 / 1024).toFixed(0);
    showSizeError(fileMB, MAX_MB, isVideo);
    return;
  }

  $('loadingWrap').classList.add('active');
  $('loadingTxt').textContent = isVideo ? 'Extracting audio…' : 'Loading audio…';
  hardReset();

  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 512;
    analyser.smoothingTimeConstant = 0.82;
    analyser.connect(audioCtx.destination);
    freqData = new Uint8Array(analyser.frequencyBinCount);

    const ab = await file.arrayBuffer();
    audioBuffer = await audioCtx.decodeAudioData(ab);
    waveDataFull = extractWaveform(audioBuffer, 256);

    $('loadingWrap').classList.remove('active');
    setupWorkspace(file.name, isVideo);

    // Show FFmpeg note on first visit
    if (!ffmpegReady) $('ffmpegNote').style.display = 'block';
  } catch(err) {
    $('loadingWrap').classList.remove('active');
    toast('Could not load this file.<br>Try MP3, WAV, or MP4 with AAC audio.', 7000);
    console.error(err);
  }
}

function showSizeError(fileMB, maxMB, isVideo) {
  const tip = isVideo
    ? 'Tip: In Premiere export audio only — File → Export → Media → Format: MP3'
    : 'Tip: Compress with Audacity or an online converter.';
  toast(`<b>File too large — ${fileMB} MB</b><br>Max allowed: <b>${maxMB} MB</b><br><br><span style="color:rgba(255,255,255,0.5);font-size:0.6rem">${tip}</span>`, 10000);
  const z = $('uploadZone');
  z.style.borderColor = '#e53935'; z.style.background = '#fff8f8';
  setTimeout(() => { z.style.borderColor = ''; z.style.background = ''; }, 2500);
}

function hardReset() {
  if (animFrame) { cancelAnimationFrame(animFrame); animFrame = null; }
  if (recAF)     { cancelAnimationFrame(recAF);     recAF = null; }
  try { source    && source.stop();    } catch(e){}
  try { recSource && recSource.stop(); } catch(e){}
  try { audioCtx    && audioCtx.close();    } catch(e){}
  try { recAudioCtx && recAudioCtx.close(); } catch(e){}
  if (exportCanvas) { exportCanvas.width = 0; exportCanvas.height = 0; exportCanvas = null; exportCtx = null; }
  audioCtx = analyser = source = audioBuffer = null;
  recAudioCtx = recAnalyser = recSource = recFreqData = null;
  waveDataFull = freqData = null;
  recordedChunks = [];
  mediaRecorder = null;
  isPlaying = false; isRecording = false; isConverting = false;
  pauseOffset = 0; startTime = 0;
}

function extractWaveform(buf, samples) {
  const raw = buf.getChannelData(0);
  const block = Math.floor(raw.length / samples);
  const out = new Float32Array(samples);
  for (let i = 0; i < samples; i++) {
    let s = 0;
    for (let j = 0; j < block; j++) s += Math.abs(raw[i * block + j]);
    out[i] = s / block;
  }
  let max = 0.001;
  for (let i = 0; i < samples; i++) if (out[i] > max) max = out[i];
  for (let i = 0; i < samples; i++) out[i] /= max;
  return out;
}

function setupWorkspace(fileName, isVideo) {
  $('fileName').textContent     = fileName;
  $('fileDuration').textContent = formatTime(audioBuffer.duration);
  $('totalTime').textContent    = formatTime(audioBuffer.duration);
  $('canvasLabel').textContent  = fileName.replace(/\.[^.]+$/, '');
  const badge = $('fileTypeBadge');
  badge.textContent = isVideo ? 'VIDEO' : 'AUDIO';
  badge.className   = `file-type-tag ${isVideo ? 'video' : 'audio'}`;
  $('videoNote').classList.toggle('show', isVideo);
  if (isVideo && !$('transparentToggle').checked) {
    $('transparentToggle').checked = true; applyTransparent(true);
  }
  $('uploadSection').style.display = 'none';
  const ws = $('workspace');
  ws.style.display = 'flex'; ws.classList.add('visible');
  setupCanvas(); drawStatic(); updatePlayBtn(false);
}

// ─── Canvas ───────────────────────────────────────────────────────────────────
const bgCvs = $('bgCanvas'), wCvs = $('waveCanvas');
let bgCtx, wCtx, W, H;

function setupCanvas() {
  const wrap = $('canvasWrap');
  W = wrap.clientWidth; H = wrap.clientHeight;
  bgCvs.width = wCvs.width = W; bgCvs.height = wCvs.height = H;
  bgCtx = bgCvs.getContext('2d');
  wCtx  = wCvs.getContext('2d', { alpha: true });
}
window.addEventListener('resize', () => { if (audioBuffer && !isRecording) { setupCanvas(); drawStatic(); } });

// ─── Transparent ─────────────────────────────────────────────────────────────
$('transparentToggle').addEventListener('change', function() { applyTransparent(this.checked); });
function applyTransparent(on) {
  isTransparent = on;
  $('canvasWrap').classList.toggle('has-bg', !on);
  $('bgColorGroup').style.cssText = on ? 'opacity:0.25;pointer-events:none' : '';
  $('bgStyleGroup').style.cssText = on ? 'opacity:0.25;pointer-events:none' : '';
  $('transTip').classList.toggle('show', on);
  // In transparent mode, export button changes to WebM
  $('exportVideoBtn').textContent = on ? 'Export WebM (alpha)' : 'Export MP4';
  if (!isPlaying && !isRecording) drawStatic();
}

// ─── Background ──────────────────────────────────────────────────────────────
function drawBg(ctx, w, h) {
  ctx.clearRect(0, 0, w, h);
  if (isTransparent) return;
  const bg = $('bgColor').value, mode = $('bgStyle').value;
  if (mode === 'solid') {
    ctx.fillStyle = bg; ctx.fillRect(0, 0, w, h);
  } else if (mode === 'gradient') {
    const g = ctx.createLinearGradient(0, 0, w, h);
    g.addColorStop(0, bg); g.addColorStop(1, shiftHue(bg, 40));
    ctx.fillStyle = g; ctx.fillRect(0, 0, w, h);
  } else {
    const g = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, w*0.65);
    g.addColorStop(0, lighten(bg, 0.06)); g.addColorStop(1, '#000');
    ctx.fillStyle = g; ctx.fillRect(0, 0, w, h);
  }
}

// ─── Waveform draw ────────────────────────────────────────────────────────────
function drawWave(ctx, data, len, color, w, h, alpha) {
  const isUint = data instanceof Uint8Array;
  const bw   = parseInt($('barWidth').value);
  const gap  = Math.max(1, Math.floor(bw * 0.5));
  const sens = parseFloat($('sensitivity').value);
  ctx.globalAlpha = alpha;

  if (waveStyle === 'bars' || waveStyle === 'mirror') {
    const mirror = waveStyle === 'mirror';
    const cols = Math.floor(w / (bw + gap));
    const step = Math.floor(len / cols);
    const cy = h / 2;
    ctx.fillStyle = color;
    for (let i = 0; i < cols; i++) {
      const val  = isUint ? (data[i*step]||0)/255 : (data[i*step]||0);
      const barH = val * h * 0.82 * sens;
      const x    = i * (bw + gap);
      if (mirror) { ctx.fillRect(x, cy-barH/2, bw, barH/2); ctx.fillRect(x, cy, bw, barH/2); }
      else        { ctx.fillRect(x, h-barH, bw, barH); }
    }
  } else if (waveStyle === 'line') {
    ctx.strokeStyle = color; ctx.lineWidth = 1.5;
    for (let dir = -1; dir <= 1; dir += 2) {
      ctx.beginPath();
      for (let i = 0; i < len; i++) {
        const val = isUint ? (data[i]||0)/255 : (data[i]||0);
        const x = (i/len)*w, y = h/2 + dir*val*h*0.44*sens;
        i===0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
      }
      ctx.stroke();
    }
  } else {
    const cx=w/2, cy=h/2, r=Math.min(w,h)*0.26;
    ctx.strokeStyle=color; ctx.lineWidth=1.5;
    ctx.beginPath();
    for (let i=0; i<=len; i++) {
      const val=(isUint?(data[i%len]||0)/255:(data[i%len]||0));
      const angle=(i/len)*Math.PI*2-Math.PI/2;
      const rr=r+val*r*0.82*sens;
      const x=cx+Math.cos(angle)*rr, y=cy+Math.sin(angle)*rr;
      i===0?ctx.moveTo(x,y):ctx.lineTo(x,y);
    }
    ctx.closePath(); ctx.stroke();
  }
  ctx.globalAlpha = 1;
}

function drawStatic() {
  if (!waveDataFull) return;
  drawBg(bgCtx, W, H);
  wCtx.clearRect(0, 0, W, H);
  drawWave(wCtx, waveDataFull, waveDataFull.length, $('waveColor').value, W, H, 0.3);
}

function drawLive() {
  analyser.getByteFrequencyData(freqData);
  const color = $('waveColor').value;
  drawBg(bgCtx, W, H);
  wCtx.clearRect(0, 0, W, H);
  drawWave(wCtx, waveDataFull, waveDataFull.length, color, W, H, 0.1);
  drawWave(wCtx, freqData, freqData.length, color, W, H, 1);

  const elapsed = audioCtx.currentTime - startTime + pauseOffset;
  $('progressBar').style.width = (Math.min(elapsed/audioBuffer.duration,1)*100)+'%';
  $('currentTime').textContent = formatTime(Math.min(elapsed, audioBuffer.duration));

  if (isPlaying && elapsed < audioBuffer.duration) {
    animFrame = requestAnimationFrame(drawLive);
  } else if (isPlaying) { stopAudio(); }
}

// ─── Playback ─────────────────────────────────────────────────────────────────
function playAudio() {
  if (!audioBuffer || isRecording || isConverting) return;
  if (audioCtx.state === 'suspended') audioCtx.resume();
  source = audioCtx.createBufferSource();
  source.buffer = audioBuffer; source.connect(analyser);
  source.start(0, pauseOffset);
  startTime = audioCtx.currentTime; isPlaying = true;
  updatePlayBtn(true); animFrame = requestAnimationFrame(drawLive);
}
function pauseAudio() {
  if (!isPlaying) return;
  pauseOffset += audioCtx.currentTime - startTime;
  try{source.stop();}catch(e){}
  isPlaying=false; cancelAnimationFrame(animFrame); animFrame=null; updatePlayBtn(false);
}
function stopAudio() {
  try{source&&source.stop();}catch(e){}
  isPlaying=false; pauseOffset=0;
  cancelAnimationFrame(animFrame); animFrame=null;
  updatePlayBtn(false);
  $('progressBar').style.width='0%'; $('currentTime').textContent='0:00';
  drawStatic();
}

$('playBtn').addEventListener('click', () => {
  if (isRecording||isConverting) return;
  if (isPlaying) pauseAudio(); else playAudio();
});
function updatePlayBtn(p) {
  $('playIcon').innerHTML = p
    ? '<path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>'
    : '<path d="M8 5v14l11-7z"/>';
}
$('progressWrap').addEventListener('click', e => {
  if (isRecording||isConverting||!audioBuffer) return;
  const pct=(e.clientX-e.currentTarget.getBoundingClientRect().left)/e.currentTarget.offsetWidth;
  pauseOffset=pct*audioBuffer.duration;
  if(isPlaying){try{source.stop();}catch(e){}cancelAnimationFrame(animFrame);isPlaying=false;playAudio();}
  $('progressBar').style.width=(pct*100)+'%'; $('currentTime').textContent=formatTime(pauseOffset);
});

// ─── Controls ─────────────────────────────────────────────────────────────────
document.querySelectorAll('.style-tab').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.style-tab').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active'); waveStyle=btn.dataset.style;
    if(!isPlaying&&!isRecording) drawStatic();
  });
});
$('barWidth').addEventListener('input',function(){$('barWidthVal').textContent=this.value;if(!isPlaying&&!isRecording)drawStatic();});
$('sensitivity').addEventListener('input',function(){$('sensitivityVal').textContent=parseFloat(this.value).toFixed(1);if(!isPlaying&&!isRecording)drawStatic();});
['waveColor','bgColor','bgStyle'].forEach(id=>{$(id).addEventListener('input',()=>{if(!isPlaying&&!isRecording)drawStatic();});});

// ─── PNG export ───────────────────────────────────────────────────────────────
$('exportPngBtn').addEventListener('click', () => {
  const out=document.createElement('canvas');
  out.width=W; out.height=H;
  const ctx=out.getContext('2d');
  if(!isTransparent) ctx.drawImage(bgCvs,0,0);
  ctx.drawImage(wCvs,0,0);
  const a=document.createElement('a');
  a.download=isTransparent?'jylabs-waveform-transparent.png':'jylabs-waveform.png';
  a.href=out.toDataURL('image/png'); a.click();
  out.width=0; out.height=0;
});

// ─── Status bar helpers ───────────────────────────────────────────────────────
function setStatus(text, time, fillPct) {
  $('statusBar').classList.add('active');
  $('statusText').textContent = text;
  $('statusTime').textContent = time;
  $('statusFill').style.width = (fillPct * 100) + '%';
}
function clearStatus() {
  $('statusBar').classList.remove('active');
  $('statusFill').style.width = '0%';
}

function setBusy(busy) {
  $('playBtn').disabled      = busy;
  $('exportPngBtn').disabled = busy;
  $('resetBtn').disabled     = busy;
  $('exportVideoBtn').textContent = busy ? 'Stop & Save' : (isTransparent ? 'Export WebM (alpha)' : 'Export MP4');
  $('exportVideoBtn').className   = busy ? 'btn btn-stop' : 'btn btn-primary';
}

// ─── Video export ─────────────────────────────────────────────────────────────
$('exportVideoBtn').addEventListener('click', () => {
  if (isRecording) { stopRecording(true); return; } // user manually stopped
  if (isConverting) return;
  startRecording();
});

function startRecording() {
  if (isPlaying) pauseAudio();

  // Export canvas: 854×480 — good quality for a waveform, low memory
  const EW=854, EH=480;
  exportCanvas=document.createElement('canvas');
  exportCanvas.width=EW; exportCanvas.height=EH;
  exportCtx=exportCanvas.getContext('2d',{alpha:true});

  // Always record WebM first; if not transparent, convert to MP4 via FFmpeg after
  const codecs=['video/webm;codecs=vp9','video/webm;codecs=vp8','video/webm'];
  const mimeType=codecs.find(c=>MediaRecorder.isTypeSupported(c))||'video/webm';
  const stream=exportCanvas.captureStream(24);
  recordedChunks=[];

  try {
    mediaRecorder=new MediaRecorder(stream,{mimeType,videoBitsPerSecond:1_500_000});
  } catch(e) {
    mediaRecorder=new MediaRecorder(stream,{videoBitsPerSecond:1_000_000});
  }

  mediaRecorder.ondataavailable=e=>{if(e.data&&e.data.size>0)recordedChunks.push(e.data);};
  mediaRecorder.onstop=()=>onRecordingDone(mimeType);
  mediaRecorder.start(1000);

  // Silent audio context for frequency analysis
  recAudioCtx=new(window.AudioContext||window.webkitAudioContext)();
  recAnalyser=recAudioCtx.createAnalyser();
  recAnalyser.fftSize=512; recAnalyser.smoothingTimeConstant=0.82;
  const sg=recAudioCtx.createGain(); sg.gain.value=0;
  recAnalyser.connect(sg); sg.connect(recAudioCtx.destination);
  recFreqData=new Uint8Array(recAnalyser.frequencyBinCount);
  recSource=recAudioCtx.createBufferSource();
  recSource.buffer=audioBuffer; recSource.connect(recAnalyser); recSource.start(0);
  recStartWallTime=recAudioCtx.currentTime;

  isRecording=true;
  setBusy(true);
  setStatus('Recording waveform…', '0:00', 0);
  renderExportFrame();
}

function renderExportFrame() {
  if (!isRecording) return;
  const elapsed=recAudioCtx.currentTime-recStartWallTime;
  recAnalyser.getByteFrequencyData(recFreqData);

  const color=$('waveColor').value;
  const EW=exportCanvas.width, EH=exportCanvas.height;
  exportCtx.clearRect(0,0,EW,EH);
  drawBg(exportCtx,EW,EH);
  drawWave(exportCtx,waveDataFull,waveDataFull.length,color,EW,EH,0.1);
  drawWave(exportCtx,recFreqData,recFreqData.length,color,EW,EH,1);

  const progress=Math.min(elapsed/audioBuffer.duration,1);
  $('progressBar').style.width=(progress*100)+'%';
  $('currentTime').textContent=formatTime(Math.min(elapsed,audioBuffer.duration));
  setStatus('Recording waveform…', formatTime(elapsed)+' / '+formatTime(audioBuffer.duration), progress);

  if (elapsed>=audioBuffer.duration) { stopRecording(false); return; }
  recAF=requestAnimationFrame(renderExportFrame);
}

function stopRecording(userCancelled) {
  isRecording=false;
  cancelAnimationFrame(recAF); recAF=null;
  try{recSource&&recSource.stop();}catch(e){}
  try{recAudioCtx&&recAudioCtx.close();}catch(e){}
  recAudioCtx=recAnalyser=recSource=recFreqData=null;
  try{if(mediaRecorder&&mediaRecorder.state!=='inactive')mediaRecorder.stop();}catch(e){}
  // mediaRecorder.onstop → onRecordingDone fires after this
  if (userCancelled) {
    // Clean up without converting
    recordedChunks=[];
    if(exportCanvas){exportCanvas.width=0;exportCanvas.height=0;exportCanvas=null;exportCtx=null;}
    setBusy(false); clearStatus(); drawStatic();
    $('progressBar').style.width='0%'; $('currentTime').textContent='0:00';
  }
}

async function onRecordingDone(mimeType) {
  // Free export canvas GPU memory
  if(exportCanvas){exportCanvas.width=0;exportCanvas.height=0;exportCanvas=null;exportCtx=null;}

  $('progressBar').style.width='0%'; $('currentTime').textContent='0:00';
  drawStatic();

  const webmBlob=new Blob(recordedChunks,{type:mimeType||'video/webm'});
  recordedChunks=[]; // free immediately

  // If transparent mode — just download the WebM (alpha)
  if (isTransparent) {
    downloadBlob(webmBlob,'jylabs-waveform-transparent.webm');
    setBusy(false); clearStatus();
    toast('<b>Saved: jylabs-waveform-transparent.webm</b><br>Premiere → drag above footage → blend: Normal<br>After Effects → Interpret Alpha: Straight', 8000);
    return;
  }

  // ── Convert WebM → MP4 via FFmpeg WASM ────────────────────────
  isConverting=true;
  setStatus('Loading FFmpeg…', '', 0);

  const ok=await ensureFFmpeg();
  if (!ok) {
    // FFmpeg failed to load — fall back to WebM download
    downloadBlob(webmBlob,'jylabs-waveform.webm');
    setBusy(false); clearStatus(); isConverting=false;
    toast('<b>FFmpeg unavailable — saved as WebM instead.</b><br>Try Chrome or Edge for MP4 export.', 8000);
    return;
  }

  try {
    setStatus('Converting to MP4…', '0%', 0);
    const ff=ffmpegInstance;

    // Write WebM into FFmpeg virtual filesystem
    const webmData=new Uint8Array(await webmBlob.arrayBuffer());
    await ff.writeFile('input.webm', webmData);

    // Convert: WebM → MP4 (H.264, fast preset, web-compatible)
    await ff.exec([
      '-i',        'input.webm',
      '-c:v',      'libx264',
      '-preset',   'ultrafast',  // fastest encode, reasonable quality
      '-crf',      '23',          // quality: 18=high, 28=low, 23=default
      '-movflags', '+faststart',  // optimise for web streaming
      '-pix_fmt',  'yuv420p',    // Premiere / broad compatibility
      '-an',                      // no audio track (waveform only)
      'output.mp4'
    ]);

    const mp4Data=await ff.readFile('output.mp4');
    const mp4Blob=new Blob([mp4Data.buffer],{type:'video/mp4'});

    // Clean up FFmpeg virtual FS
    try{await ff.deleteFile('input.webm');}catch(e){}
    try{await ff.deleteFile('output.mp4');}catch(e){}

    downloadBlob(mp4Blob,'jylabs-waveform.mp4');
    setBusy(false); clearStatus(); isConverting=false;
    $('ffmpegNote').style.display='none'; // hide first-time note
    toast('<b>Saved: jylabs-waveform.mp4</b><br>Import directly into Premiere Pro.', 5000);

  } catch(err) {
    console.error('FFmpeg conversion error:', err);
    // Fall back to WebM
    downloadBlob(webmBlob,'jylabs-waveform.webm');
    setBusy(false); clearStatus(); isConverting=false;
    toast('<b>MP4 conversion failed — saved as WebM.</b>', 6000);
  }
}

function downloadBlob(blob, filename) {
  const url=URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download=filename; a.click();
  setTimeout(()=>URL.revokeObjectURL(url), 10000);
}

// ─── Reset ────────────────────────────────────────────────────────────────────
$('resetBtn').addEventListener('click', () => {
  if(isRecording) stopRecording(true);
  hardReset(); isVideoSource=false;
  $('workspace').style.display='none'; $('workspace').classList.remove('visible');
  $('uploadSection').style.display='flex';
  fileInput.value='';
  $('transparentToggle').checked=false; applyTransparent(false);
  $('videoNote').classList.remove('show');
  $('canvasWrap').classList.add('has-bg');
  $('progressBar').style.width='0%'; $('currentTime').textContent='0:00';
  clearStatus(); setBusy(false);
  $('ffmpegNote').style.display='none';
});

// ─── Colour helpers ───────────────────────────────────────────────────────────
function shiftHue(hex,deg){const[r,g,b]=hexToRgb(hex),[h,s,l]=rgbToHsl(r,g,b),[r2,g2,b2]=hslToRgb((h+deg/360)%1,s,l);return`rgb(${r2},${g2},${b2})`;}
function lighten(hex,amt){const[r,g,b]=hexToRgb(hex);return`rgb(${Math.min(255,(r+amt*255)|0)},${Math.min(255,(g+amt*255)|0)},${Math.min(255,(b+amt*255)|0)})`;}
function hexToRgb(h){return[parseInt(h.slice(1,3),16),parseInt(h.slice(3,5),16),parseInt(h.slice(5,7),16)];}
function rgbToHsl(r,g,b){r/=255;g/=255;b/=255;const mx=Math.max(r,g,b),mn=Math.min(r,g,b);let h,s,l=(mx+mn)/2;if(mx===mn){h=s=0;}else{const d=mx-mn;s=l>.5?d/(2-mx-mn):d/(mx+mn);switch(mx){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;default:h=(r-g)/d+4;}h/=6;}return[h,s,l];}
function hslToRgb(h,s,l){if(!s)return[l*255,l*255,l*255].map(Math.round);const q=l<.5?l*(1+s):l+s-l*s,p=2*l-q,f=(p,q,t)=>{t<0&&(t+=1);t>1&&(t-=1);return t<1/6?p+(q-p)*6*t:t<.5?q:t<2/3?p+(q-p)*(2/3-t)*6:p;};return[f(p,q,h+1/3),f(p,q,h),f(p,q,h-1/3)].map(v=>Math.round(v*255));}
function formatTime(s){s=Math.max(0,s);return`${Math.floor(s/60)}:${String(Math.floor(s%60)).padStart(2,'0')}`;}
function toast(html,dur=5000){const t=document.createElement('div');t.className='toast';t.innerHTML=html;document.body.appendChild(t);setTimeout(()=>{t.style.opacity='0';setTimeout(()=>t.remove(),600);},dur);}
</script>
</body>
</html>
