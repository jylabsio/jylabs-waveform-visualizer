<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>jylabs — Waveform</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=Geist+Mono:wght@300;400;500&family=Geist:wght@300;400;500;700&display=swap');

:root {
  --white: #ffffff;
  --black: #0a0a0a;
  --gray-100: #f5f5f5;
  --gray-200: #e8e8e8;
  --gray-300: #d0d0d0;
  --gray-500: #888888;
  --gray-700: #444444;
  --border: #e0e0e0;
  --mono: 'Geist Mono', monospace;
  --sans: 'Geist', sans-serif;
  --serif: 'Instrument Serif', serif;
}

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html { font-size: 16px; }
body { background: var(--white); color: var(--black); font-family: var(--sans); min-height: 100vh; -webkit-font-smoothing: antialiased; }

/* ── Header ── */
header {
  position: fixed; top: 0; left: 0; right: 0; height: 56px;
  display: flex; align-items: center; justify-content: space-between;
  padding: 0 32px;
  background: rgba(255,255,255,0.94); backdrop-filter: blur(12px);
  border-bottom: 1px solid var(--border); z-index: 100;
}
.logo-wrap { display: flex; align-items: baseline; gap: 10px; }
.logo-name { font-family: var(--mono); font-size: 0.85rem; font-weight: 500; letter-spacing: -0.01em; }
.logo-dot { width: 5px; height: 5px; border-radius: 50%; background: var(--black); margin-bottom: 2px; flex-shrink: 0; }
.logo-product { font-family: var(--mono); font-size: 0.72rem; font-weight: 300; color: var(--gray-500); letter-spacing: 0.08em; text-transform: uppercase; }
.nav-tag { font-family: var(--mono); font-size: 0.62rem; letter-spacing: 0.12em; text-transform: uppercase; color: var(--gray-500); padding: 4px 10px; border: 1px solid var(--border); border-radius: 2px; }

/* ── Page ── */
.page { padding-top: 56px; min-height: 100vh; display: flex; flex-direction: column; }

/* ── Upload ── */
#uploadSection {
  flex: 1; display: flex; flex-direction: column;
  align-items: center; justify-content: center; padding: 80px 40px;
}
.hero-eyebrow {
  font-family: var(--mono); font-size: 0.65rem; letter-spacing: 0.2em;
  text-transform: uppercase; color: var(--gray-500); margin-bottom: 20px;
  display: flex; align-items: center; gap: 10px;
}
.hero-eyebrow::before, .hero-eyebrow::after { content: ''; display: block; width: 32px; height: 1px; background: var(--gray-300); }
.hero-title { font-family: var(--serif); font-size: clamp(2.6rem, 5.5vw, 4.5rem); font-weight: 400; line-height: 1.07; letter-spacing: -0.02em; text-align: center; margin-bottom: 14px; }
.hero-title em { font-style: italic; color: var(--gray-700); }
.hero-sub { font-family: var(--sans); font-size: 0.88rem; font-weight: 300; color: var(--gray-500); text-align: center; margin-bottom: 52px; }
.drop-zone {
  width: 100%; max-width: 640px; border: 1.5px dashed var(--gray-300); border-radius: 6px;
  padding: 52px 40px; text-align: center; cursor: pointer; transition: all 0.22s ease;
  background: var(--white);
}
.drop-zone:hover, .drop-zone.drag-over { border-color: var(--black); background: var(--gray-100); }
.drop-icon { width: 40px; height: 40px; margin: 0 auto 16px; display: flex; align-items: center; justify-content: center; }
.drop-icon svg { width: 34px; height: 34px; stroke: var(--black); stroke-width: 1.3; }
.drop-title { font-family: var(--sans); font-size: 0.95rem; font-weight: 500; margin-bottom: 5px; }
.drop-sub { font-family: var(--mono); font-size: 0.68rem; color: var(--gray-500); letter-spacing: 0.04em; margin-bottom: 20px; }
.format-pills { display: flex; gap: 6px; justify-content: center; flex-wrap: wrap; }
.pill { font-family: var(--mono); font-size: 0.58rem; letter-spacing: 0.1em; padding: 3px 9px; border-radius: 2px; border: 1px solid var(--border); color: var(--gray-500); }
.pill.v { border-color: var(--gray-300); color: var(--gray-700); }
#fileInput { display: none; }

/* ── Loading ── */
.loading-wrap { width: 100%; max-width: 640px; margin-top: 20px; display: none; }
.loading-wrap.active { display: block; }
.loading-bar { height: 2px; background: var(--gray-200); border-radius: 1px; overflow: hidden; }
.loading-fill { height: 100%; background: linear-gradient(90deg, var(--gray-300), var(--black), var(--gray-300)); background-size: 200% 100%; animation: shimmer 1.1s linear infinite; }
@keyframes shimmer { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
.loading-txt { font-family: var(--mono); font-size: 0.63rem; letter-spacing: 0.1em; color: var(--gray-500); text-align: center; margin-top: 10px; }

/* ── Workspace ── */
#workspace { display: none; flex: 1; flex-direction: column; }
@keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
#workspace.visible { display: flex; animation: fadeIn 0.3s ease forwards; }

/* ── File bar ── */
.file-bar {
  border-bottom: 1px solid var(--border); padding: 0 32px; height: 44px;
  display: flex; align-items: center; gap: 14px; background: var(--gray-100);
}
.file-indicator { width: 6px; height: 6px; border-radius: 50%; background: var(--black); animation: blink 2.5s ease-in-out infinite; flex-shrink: 0; }
@keyframes blink { 0%,100%{opacity:1;}50%{opacity:0.25;} }
.file-name-text { font-family: var(--mono); font-size: 0.72rem; color: var(--black); flex: 1; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.file-type-tag { font-family: var(--mono); font-size: 0.58rem; letter-spacing: 0.12em; padding: 2px 8px; border-radius: 2px; flex-shrink: 0; }
.file-type-tag.video { background: var(--black); color: var(--white); }
.file-type-tag.audio { background: var(--gray-200); color: var(--black); }
.file-dur { font-family: var(--mono); font-size: 0.68rem; color: var(--gray-500); flex-shrink: 0; }

/* ── Canvas ── */
.canvas-section {
  position: relative; aspect-ratio: 16/9; overflow: hidden; flex-shrink: 0;
  background-image: linear-gradient(45deg,#1a1a1a 25%,transparent 25%), linear-gradient(-45deg,#1a1a1a 25%,transparent 25%), linear-gradient(45deg,transparent 75%,#1a1a1a 75%), linear-gradient(-45deg,transparent 75%,#1a1a1a 75%);
  background-size: 16px 16px; background-position: 0 0,0 8px,8px -8px,-8px 0; background-color: #111;
}
.canvas-section.has-bg { background: var(--black); }
#bgCanvas, #waveCanvas { position: absolute; inset: 0; width: 100%; height: 100%; }
#bgCanvas { z-index: 1; } #waveCanvas { z-index: 2; }
.canvas-ui { position: absolute; inset: 0; z-index: 3; pointer-events: none; display: flex; align-items: flex-end; justify-content: space-between; padding: 18px 22px; }
.canvas-label { font-family: var(--mono); font-size: 0.58rem; letter-spacing: 0.14em; color: rgba(255,255,255,0.22); text-transform: uppercase; }
.canvas-brand { font-family: var(--mono); font-size: 0.58rem; letter-spacing: 0.1em; color: rgba(255,255,255,0.15); }

/* ── Controls panel ── */
.controls-panel { border-top: 1px solid var(--border); display: grid; grid-template-columns: 1fr 300px; }
.controls-left { padding: 26px 32px; border-right: 1px solid var(--border); }
.controls-right { padding: 26px 26px; display: flex; flex-direction: column; gap: 16px; }

/* Playback */
.playback-row { display: flex; align-items: center; gap: 14px; margin-bottom: 26px; }
.play-btn { width: 42px; height: 42px; border-radius: 50%; background: var(--black); border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: background 0.15s; flex-shrink: 0; }
.play-btn:hover { background: var(--gray-700); }
.play-btn:disabled { opacity: 0.3; cursor: not-allowed; }
.play-btn svg { width: 18px; height: 18px; fill: var(--white); }
.progress-track { flex: 1; height: 2px; background: var(--gray-200); border-radius: 1px; cursor: pointer; position: relative; }
.progress-fill { height: 100%; background: var(--black); border-radius: 1px; width: 0%; pointer-events: none; transition: width 0.08s linear; }
.time-txt { font-family: var(--mono); font-size: 0.67rem; color: var(--gray-500); white-space: nowrap; min-width: 80px; text-align: right; }

/* Style tabs */
.ctrl-label { font-family: var(--mono); font-size: 0.58rem; letter-spacing: 0.18em; text-transform: uppercase; color: var(--gray-500); margin-bottom: 10px; }
.style-tabs { display: flex; border: 1px solid var(--border); border-radius: 4px; overflow: hidden; margin-bottom: 22px; }
.style-tab { flex: 1; padding: 9px 6px; background: var(--white); border: none; border-right: 1px solid var(--border); font-family: var(--mono); font-size: 0.6rem; letter-spacing: 0.06em; color: var(--gray-500); cursor: pointer; transition: all 0.14s; text-align: center; }
.style-tab:last-child { border-right: none; }
.style-tab:hover { background: var(--gray-100); color: var(--black); }
.style-tab.active { background: var(--black); color: var(--white); }

/* Param sliders */
.params-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 18px 24px; }
.param-label { font-family: var(--mono); font-size: 0.58rem; letter-spacing: 0.14em; text-transform: uppercase; color: var(--gray-500); margin-bottom: 8px; display: flex; justify-content: space-between; }
.param-val { color: var(--black); font-weight: 500; }
input[type="range"] { width: 100%; -webkit-appearance: none; height: 2px; background: var(--gray-200); border-radius: 1px; outline: none; cursor: pointer; }
input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; border-radius: 50%; background: var(--black); cursor: pointer; border: 2px solid var(--white); box-shadow: 0 0 0 1px var(--black); }

/* Colors */
.color-row { display: flex; gap: 10px; margin-top: 20px; }
.color-group { flex: 1; }
.color-group label { font-family: var(--mono); font-size: 0.58rem; letter-spacing: 0.14em; text-transform: uppercase; color: var(--gray-500); display: block; margin-bottom: 7px; }
input[type="color"] { width: 100%; height: 34px; border: 1px solid var(--border); border-radius: 3px; background: var(--white); cursor: pointer; padding: 2px; }
select.ctrl-select { width: 100%; height: 34px; background: var(--white); border: 1px solid var(--border); color: var(--black); padding: 0 10px; border-radius: 3px; font-family: var(--mono); font-size: 0.63rem; cursor: pointer; outline: none; -webkit-appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6' viewBox='0 0 10 6'%3E%3Cpath d='M0 0l5 6 5-6z' fill='%23888'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 10px center; }

/* Toggle */
.toggle-item { display: flex; align-items: center; justify-content: space-between; padding: 14px 0; border-top: 1px solid var(--border); margin-top: 18px; }
.toggle-title { font-family: var(--sans); font-size: 0.8rem; font-weight: 500; margin-bottom: 2px; }
.toggle-sub { font-family: var(--mono); font-size: 0.6rem; color: var(--gray-500); }
.switch { position: relative; width: 40px; height: 22px; flex-shrink: 0; }
.switch input { opacity: 0; width: 0; height: 0; }
.switch-track { position: absolute; inset: 0; background: var(--gray-200); border-radius: 11px; cursor: pointer; transition: background 0.2s; border: 1px solid var(--border); }
.switch-track::before { content: ''; position: absolute; width: 16px; height: 16px; left: 2px; top: 2px; background: var(--white); border-radius: 50%; transition: transform 0.2s; box-shadow: 0 1px 3px rgba(0,0,0,0.12); }
.switch input:checked + .switch-track { background: var(--black); border-color: var(--black); }
.switch input:checked + .switch-track::before { transform: translateX(18px); }

/* Right panel */
.section-head { font-family: var(--mono); font-size: 0.58rem; letter-spacing: 0.18em; text-transform: uppercase; color: var(--gray-500); padding-bottom: 12px; border-bottom: 1px solid var(--border); margin-bottom: 14px; }
.info-note { display: none; padding: 11px 13px; background: var(--gray-100); border-radius: 3px; border-left: 2px solid var(--black); font-family: var(--mono); font-size: 0.61rem; color: var(--gray-700); line-height: 1.8; }
.info-note.show { display: block; }
.info-note strong { color: var(--black); }

/* Recording */
.rec-bar { display: none; align-items: center; gap: 10px; padding: 11px 13px; background: var(--black); border-radius: 3px; }
.rec-bar.active { display: flex; }
.rec-dot { width: 7px; height: 7px; border-radius: 50%; background: #fff; animation: recpulse 1s ease-in-out infinite; flex-shrink: 0; }
@keyframes recpulse { 0%,100%{opacity:1;}50%{opacity:0.2;} }
.rec-text { font-family: var(--mono); font-size: 0.64rem; color: var(--white); flex: 1; }
.rec-time { font-family: var(--mono); font-size: 0.64rem; color: rgba(255,255,255,0.45); }

/* Buttons */
.btn-group { display: flex; flex-direction: column; gap: 8px; margin-top: auto; }
.btn { width: 100%; padding: 11px 16px; border-radius: 3px; font-family: var(--mono); font-size: 0.68rem; letter-spacing: 0.07em; cursor: pointer; transition: all 0.15s; border: none; text-align: center; }
.btn-primary { background: var(--black); color: var(--white); font-weight: 500; }
.btn-primary:hover { background: var(--gray-700); }
.btn-secondary { background: var(--white); color: var(--black); border: 1px solid var(--border); }
.btn-secondary:hover { background: var(--gray-100); }
.btn-ghost { background: transparent; color: var(--gray-500); border: 1px solid var(--border); }
.btn-ghost:hover { color: var(--black); border-color: var(--gray-400); }
.btn-stop { background: var(--black); color: var(--white); }
.btn:disabled { opacity: 0.35; cursor: not-allowed; pointer-events: none; }

/* Toast */
.toast { position: fixed; bottom: 28px; left: 50%; transform: translateX(-50%); background: var(--black); color: var(--white); padding: 15px 22px; border-radius: 4px; font-family: var(--mono); font-size: 0.65rem; line-height: 1.9; z-index: 9999; max-width: 480px; text-align: center; box-shadow: 0 8px 32px rgba(0,0,0,0.18); transition: opacity 0.5s; }

/* Footer */
footer { border-top: 1px solid var(--border); padding: 14px 32px; display: flex; align-items: center; justify-content: space-between; }
.footer-brand { font-family: var(--mono); font-size: 0.62rem; color: var(--gray-500); }
.footer-note { font-family: var(--mono); font-size: 0.58rem; color: var(--gray-300); }
</style>
</head>
<body>

<header>
  <div class="logo-wrap">
    <span class="logo-name">jylabs.io</span>
    <div class="logo-dot"></div>
    <span class="logo-product">Waveform</span>
  </div>
  <div style="display:flex;align-items:center;gap:10px;">
    <div class="nav-tag">Audio Visualizer</div>
    <div class="nav-tag" id="versionTag" style="cursor:default;border-color:var(--gray-300);color:var(--gray-500);">V1.1</div>
  </div>
</header>

<div class="page">

  <!-- Upload -->
  <div id="uploadSection">
    <div class="hero-eyebrow">Audio Tool</div>
    <h1 class="hero-title">Turn sound into<br><em>visual motion</em></h1>
    <p class="hero-sub">Drop an audio or video file — export a waveform overlay ready for Premiere.</p>
    <div class="drop-zone" id="uploadZone">
      <div class="drop-icon">
        <svg viewBox="0 0 24 24" fill="none" stroke-linecap="round" stroke-linejoin="round">
          <path d="M9 19V6l12-3v13"/><circle cx="6" cy="18" r="3"/><circle cx="18" cy="15" r="3"/>
        </svg>
      </div>
      <div class="drop-title">Drop your file here</div>
      <div class="drop-sub">or click to browse</div>
      <div class="format-pills">
        <span class="pill v">MP4</span><span class="pill v">MOV</span><span class="pill v">WEBM</span>
        <span class="pill">MP3</span><span class="pill">WAV</span><span class="pill">M4A</span><span class="pill">OGG</span>
      </div>
      <input type="file" id="fileInput" accept="audio/*,video/*">
    </div>
    <div class="loading-wrap" id="loadingWrap">
      <div class="loading-bar"><div class="loading-fill"></div></div>
      <div class="loading-txt" id="loadingTxt">Loading…</div>
    </div>
  </div>

  <!-- Workspace -->
  <div id="workspace">
    <div class="file-bar">
      <div class="file-indicator"></div>
      <div class="file-name-text" id="fileName">—</div>
      <span class="file-type-tag audio" id="fileTypeBadge">AUDIO</span>
      <div class="file-dur" id="fileDuration">0:00</div>
    </div>

    <div class="canvas-section has-bg" id="canvasWrap">
      <canvas id="bgCanvas"></canvas>
      <canvas id="waveCanvas"></canvas>
      <div class="canvas-ui">
        <span class="canvas-label" id="canvasLabel"></span>
        <span class="canvas-brand">jylabs.io</span>
      </div>
    </div>

    <div class="controls-panel">
      <div class="controls-left">
        <div class="playback-row">
          <button class="play-btn" id="playBtn">
            <svg viewBox="0 0 24 24" id="playIcon"><path d="M8 5v14l11-7z"/></svg>
          </button>
          <div class="progress-track" id="progressWrap">
            <div class="progress-fill" id="progressBar"></div>
          </div>
          <div class="time-txt"><span id="currentTime">0:00</span> / <span id="totalTime">0:00</span></div>
        </div>

        <div class="ctrl-label">Waveform Style</div>
        <div class="style-tabs">
          <button class="style-tab active" data-style="bars">Bars</button>
          <button class="style-tab" data-style="mirror">Mirror</button>
          <button class="style-tab" data-style="line">Line</button>
          <button class="style-tab" data-style="circle">Radial</button>
        </div>

        <div class="params-grid">
          <div>
            <div class="param-label">Bar Width <span class="param-val" id="barWidthVal">4</span></div>
            <input type="range" id="barWidth" min="1" max="16" value="4">
          </div>
          <div>
            <div class="param-label">Sensitivity <span class="param-val" id="sensitivityVal">1.5</span></div>
            <input type="range" id="sensitivity" min="0.5" max="4" step="0.1" value="1.5">
          </div>
        </div>

        <div class="color-row" id="colorControls">
          <div class="color-group">
            <label>Wave Color</label>
            <input type="color" id="waveColor" value="#ffffff">
          </div>
          <div class="color-group" id="bgColorGroup">
            <label>Background</label>
            <input type="color" id="bgColor" value="#0a0a0a">
          </div>
          <div class="color-group" id="bgStyleGroup">
            <label>BG Style</label>
            <select id="bgStyle" class="ctrl-select">
              <option value="solid">Solid</option>
              <option value="gradient">Gradient</option>
              <option value="radial">Radial</option>
            </select>
          </div>
        </div>

        <div class="toggle-item">
          <div>
            <div class="toggle-title">Transparent Background</div>
            <div class="toggle-sub">Export with alpha for compositing</div>
          </div>
          <label class="switch">
            <input type="checkbox" id="transparentToggle">
            <span class="switch-track"></span>
          </label>
        </div>
      </div>

      <div class="controls-right">
        <div>
          <div class="section-head">Export</div>
          <div class="info-note" id="videoNote">
            <strong>Video file loaded.</strong><br>Audio extracted — export a transparent WebM and composite over your footage.
          </div>
          <div class="info-note" id="transTip">
            <strong>Transparent mode on.</strong><br>
            Premiere → blend: Normal<br>
            After Effects → Interpret Alpha: Straight<br>
            DaVinci → Composite above clip
          </div>
        </div>

        <div class="rec-bar" id="recStatus">
          <div class="rec-dot"></div>
          <div class="rec-text" id="recLabel">Rendering…</div>
          <div class="rec-time" id="recTimer">0:00</div>
        </div>

        <div class="btn-group">
          <button class="btn btn-primary" id="exportVideoBtn">Export Video</button>
          <button class="btn btn-secondary" id="exportPngBtn">Export PNG Frame</button>
          <button class="btn btn-ghost" id="resetBtn">Load New File</button>
        </div>
      </div>
    </div>
  </div>

  <footer>
    <span class="footer-brand">jylabs.io — Waveform <span style="color:var(--gray-300);margin-left:8px;">V1.1</span></span>
    <span class="footer-note">Runs locally in your browser. No uploads.</span>
  </footer>
</div>

<script>
'use strict';

// ─── Version ──────────────────────────────────────────────────────────────────
const VERSION = 'V1.1';
document.getElementById('versionTag').textContent = VERSION;
document.querySelectorAll('.version-display').forEach(el => el.textContent = VERSION);

// ─── State ───────────────────────────────────────────────────────────────────
let audioCtx, analyser, source, audioBuffer;
let isPlaying = false, startTime = 0, pauseOffset = 0, animFrame;
let waveStyle = 'bars';
let waveDataFull = null;       // Float32Array — allocated once
let freqData = null;           // Uint8Array   — allocated once, reused every frame
let isTransparent = false, isRecording = false;
let mediaRecorder = null, recordedChunks = [];
let recAF = null, recStartWallTime = 0;
let recAudioCtx = null, recAnalyser = null, recSource = null;
let recFreqData = null;        // Uint8Array for recording — allocated once
let isVideoSource = false;

const $ = id => document.getElementById(id);

// ─── Upload ───────────────────────────────────────────────────────────────────
const uploadZone = $('uploadZone');
const fileInput  = $('fileInput');

uploadZone.addEventListener('click', () => fileInput.click());
uploadZone.addEventListener('dragover', e => { e.preventDefault(); uploadZone.classList.add('drag-over'); });
uploadZone.addEventListener('dragleave', () => uploadZone.classList.remove('drag-over'));
uploadZone.addEventListener('drop', e => {
  e.preventDefault(); uploadZone.classList.remove('drag-over');
  const f = e.dataTransfer.files[0]; if (f) loadFile(f);
});
fileInput.addEventListener('change', () => { if (fileInput.files[0]) loadFile(fileInput.files[0]); });

async function loadFile(file) {
  const isVideo = file.type.startsWith('video/') || /\.(mp4|mov|webm|avi|mkv)$/i.test(file.name);
  isVideoSource = isVideo;

  $('loadingWrap').classList.add('active');
  $('loadingTxt').textContent = isVideo ? 'Extracting audio from video…' : 'Loading audio…';

  // Clean up previous state
  cleanup();

  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;                  // ← halved from 2048: 512 bins instead of 1024
    analyser.smoothingTimeConstant = 0.8;
    analyser.connect(audioCtx.destination);

    // Allocate typed arrays once based on analyser size
    freqData = new Uint8Array(analyser.frequencyBinCount);

    const arrayBuf = await file.arrayBuffer();
    audioBuffer = await audioCtx.decodeAudioData(arrayBuf);

    // Extract static waveform — 400 samples is plenty, halved from 800
    waveDataFull = extractWaveform(audioBuffer, 400);

    $('loadingWrap').classList.remove('active');
    setupWorkspace(file.name, isVideo);
  } catch(err) {
    $('loadingWrap').classList.remove('active');
    toast('Could not load this file.<br>Try MP3, WAV, M4A, or MP4 with AAC audio.', 7000);
    console.error('loadFile error:', err);
  }
}

function cleanup() {
  if (animFrame) { cancelAnimationFrame(animFrame); animFrame = null; }
  if (isPlaying) { try { source && source.stop(); } catch(e){} isPlaying = false; }
  if (audioCtx) { try { audioCtx.close(); } catch(e){} audioCtx = null; }
  analyser = null; source = null; audioBuffer = null;
  waveDataFull = null; freqData = null;
  pauseOffset = 0; startTime = 0;
}

function setupWorkspace(fileName, isVideo) {
  $('fileName').textContent = fileName;
  $('fileDuration').textContent = formatTime(audioBuffer.duration);
  $('totalTime').textContent = formatTime(audioBuffer.duration);
  $('canvasLabel').textContent = fileName.replace(/\.[^.]+$/, '');

  const badge = $('fileTypeBadge');
  badge.textContent = isVideo ? 'VIDEO' : 'AUDIO';
  badge.className = `file-type-tag ${isVideo ? 'video' : 'audio'}`;

  $('videoNote').classList.toggle('show', isVideo);

  // Auto-enable transparent for video files
  if (isVideo && !$('transparentToggle').checked) {
    $('transparentToggle').checked = true;
    applyTransparent(true);
  }

  $('uploadSection').style.display = 'none';
  const ws = $('workspace');
  ws.style.display = 'flex';
  ws.classList.add('visible');

  setupCanvas();
  drawStatic();
  updatePlayBtn(false);
}

// ─── Waveform extraction ──────────────────────────────────────────────────────
function extractWaveform(buffer, samples) {
  const raw = buffer.getChannelData(0);
  const blockSize = Math.floor(raw.length / samples);
  const data = new Float32Array(samples);
  for (let i = 0; i < samples; i++) {
    let s = 0;
    for (let j = 0; j < blockSize; j++) s += Math.abs(raw[i * blockSize + j]);
    data[i] = s / blockSize;
  }
  let max = 0.001;
  for (let i = 0; i < samples; i++) if (data[i] > max) max = data[i];
  for (let i = 0; i < samples; i++) data[i] /= max;
  return data;
}

// ─── Canvas ───────────────────────────────────────────────────────────────────
const bgCvs = $('bgCanvas'), wCvs = $('waveCanvas');
let bgCtx, wCtx, W, H;

function setupCanvas() {
  const wrap = $('canvasWrap');
  W = wrap.clientWidth; H = wrap.clientHeight;
  bgCvs.width = wCvs.width = W;
  bgCvs.height = wCvs.height = H;
  bgCtx = bgCvs.getContext('2d');
  wCtx  = wCvs.getContext('2d', { alpha: true });
}

window.addEventListener('resize', () => {
  if (audioBuffer && !isRecording) { setupCanvas(); drawStatic(); }
});

// ─── Transparent toggle ───────────────────────────────────────────────────────
$('transparentToggle').addEventListener('change', function() { applyTransparent(this.checked); });

function applyTransparent(on) {
  isTransparent = on;
  $('canvasWrap').classList.toggle('has-bg', !on);
  $('bgColorGroup').style.cssText  = on ? 'opacity:0.25;pointer-events:none' : '';
  $('bgStyleGroup').style.cssText  = on ? 'opacity:0.25;pointer-events:none' : '';
  $('transTip').classList.toggle('show', on);
  if (!isPlaying && !isRecording) drawStatic();
}

// ─── Background draw ─────────────────────────────────────────────────────────
function drawBg(ctx, w, h) {
  ctx.clearRect(0, 0, w, h);
  if (isTransparent) return;
  const bg = $('bgColor').value, mode = $('bgStyle').value;
  if (mode === 'solid') {
    ctx.fillStyle = bg; ctx.fillRect(0, 0, w, h);
  } else if (mode === 'gradient') {
    const g = ctx.createLinearGradient(0, 0, w, h);
    g.addColorStop(0, bg); g.addColorStop(1, shiftHue(bg, 40));
    ctx.fillStyle = g; ctx.fillRect(0, 0, w, h);
  } else {
    const g = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, w*0.65);
    g.addColorStop(0, lighten(bg, 0.06)); g.addColorStop(1, '#000');
    ctx.fillStyle = g; ctx.fillRect(0, 0, w, h);
  }
}

// ─── Waveform drawing — all in-place, no per-frame allocations ────────────────
function drawWave(ctx, data, len, color, w, h, alpha) {
  // `data` is either a Uint8Array (freq, 0-255) or Float32Array (static, 0-1)
  // `len` = how many samples to use
  const isUint = data instanceof Uint8Array;
  const bw   = parseInt($('barWidth').value);
  const gap  = Math.max(1, Math.floor(bw * 0.5));
  const sens = parseFloat($('sensitivity').value);

  ctx.globalAlpha = alpha;

  if (waveStyle === 'bars' || waveStyle === 'mirror') {
    const mirror = waveStyle === 'mirror';
    const cols   = Math.floor(w / (bw + gap));
    const step   = Math.floor(len / cols);
    const cy     = h / 2;
    ctx.fillStyle = color;
    for (let i = 0; i < cols; i++) {
      const raw  = data[i * step] || 0;
      const val  = isUint ? raw / 255 : raw;
      const barH = val * h * 0.82 * sens;
      const x    = i * (bw + gap);
      if (mirror) {
        ctx.fillRect(x, cy - barH/2, bw, barH/2);
        ctx.fillRect(x, cy, bw, barH/2);
      } else {
        ctx.fillRect(x, h - barH, bw, barH);
      }
    }
  } else if (waveStyle === 'line') {
    ctx.strokeStyle = color; ctx.lineWidth = 1.5;
    for (let dir = -1; dir <= 1; dir += 2) {
      ctx.beginPath();
      for (let i = 0; i < len; i++) {
        const raw = data[i] || 0;
        const val = isUint ? raw / 255 : raw;
        const x = (i / len) * w;
        const y = h/2 + dir * val * h * 0.44 * sens;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      }
      ctx.stroke();
    }
  } else { // circle
    const cx = w/2, cy = h/2, r = Math.min(w, h) * 0.26;
    ctx.strokeStyle = color; ctx.lineWidth = 1.5;
    ctx.beginPath();
    for (let i = 0; i <= len; i++) {
      const raw   = data[i % len] || 0;
      const val   = isUint ? raw / 255 : raw;
      const angle = (i / len) * Math.PI * 2 - Math.PI / 2;
      const rr    = r + val * r * 0.82 * sens;
      const x     = cx + Math.cos(angle) * rr, y = cy + Math.sin(angle) * rr;
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.closePath(); ctx.stroke();
  }

  ctx.globalAlpha = 1;
}

// ─── Static preview ───────────────────────────────────────────────────────────
function drawStatic() {
  if (!waveDataFull) return;
  drawBg(bgCtx, W, H);
  wCtx.clearRect(0, 0, W, H);
  drawWave(wCtx, waveDataFull, waveDataFull.length, $('waveColor').value, W, H, 0.3);
}

// ─── Live draw — NO allocations per frame ─────────────────────────────────────
function drawLive() {
  analyser.getByteFrequencyData(freqData); // fills existing Uint8Array in-place

  const color = $('waveColor').value;
  drawBg(bgCtx, W, H);
  wCtx.clearRect(0, 0, W, H);
  // Ghost static waveform
  drawWave(wCtx, waveDataFull, waveDataFull.length, color, W, H, 0.1);
  // Live frequency
  drawWave(wCtx, freqData, freqData.length, color, W, H, 1);

  const elapsed = audioCtx.currentTime - startTime + pauseOffset;
  $('progressBar').style.width = (Math.min(elapsed / audioBuffer.duration, 1) * 100) + '%';
  $('currentTime').textContent = formatTime(Math.min(elapsed, audioBuffer.duration));

  if (isPlaying && elapsed < audioBuffer.duration) {
    animFrame = requestAnimationFrame(drawLive);
  } else if (isPlaying) {
    stopAudio();
  }
}

// ─── Playback ─────────────────────────────────────────────────────────────────
function playAudio() {
  if (!audioBuffer || isRecording) return;
  if (audioCtx.state === 'suspended') audioCtx.resume();
  source = audioCtx.createBufferSource();
  source.buffer = audioBuffer;
  source.connect(analyser);
  source.start(0, pauseOffset);
  startTime = audioCtx.currentTime; isPlaying = true;
  updatePlayBtn(true);
  animFrame = requestAnimationFrame(drawLive);
}

function pauseAudio() {
  if (!isPlaying) return;
  pauseOffset += audioCtx.currentTime - startTime;
  try { source.stop(); } catch(e){}
  isPlaying = false; cancelAnimationFrame(animFrame); animFrame = null;
  updatePlayBtn(false);
}

function stopAudio() {
  try { source && source.stop(); } catch(e){}
  isPlaying = false; pauseOffset = 0;
  cancelAnimationFrame(animFrame); animFrame = null;
  updatePlayBtn(false);
  $('progressBar').style.width = '0%';
  $('currentTime').textContent = '0:00';
  drawStatic();
}

$('playBtn').addEventListener('click', () => {
  if (isRecording) return;
  if (isPlaying) pauseAudio(); else playAudio();
});

function updatePlayBtn(playing) {
  $('playIcon').innerHTML = playing
    ? '<path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>'
    : '<path d="M8 5v14l11-7z"/>';
}

$('progressWrap').addEventListener('click', e => {
  if (isRecording || !audioBuffer) return;
  const pct = (e.clientX - e.currentTarget.getBoundingClientRect().left) / e.currentTarget.offsetWidth;
  pauseOffset = pct * audioBuffer.duration;
  if (isPlaying) { try { source.stop(); } catch(e){} cancelAnimationFrame(animFrame); isPlaying = false; playAudio(); }
  $('progressBar').style.width = (pct * 100) + '%';
  $('currentTime').textContent = formatTime(pauseOffset);
});

// ─── Style / control listeners ────────────────────────────────────────────────
document.querySelectorAll('.style-tab').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.style-tab').forEach(b => b.classList.remove('active'));
    btn.classList.add('active'); waveStyle = btn.dataset.style;
    if (!isPlaying && !isRecording) drawStatic();
  });
});

$('barWidth').addEventListener('input', function() {
  $('barWidthVal').textContent = this.value;
  if (!isPlaying && !isRecording) drawStatic();
});
$('sensitivity').addEventListener('input', function() {
  $('sensitivityVal').textContent = parseFloat(this.value).toFixed(1);
  if (!isPlaying && !isRecording) drawStatic();
});
['waveColor','bgColor','bgStyle'].forEach(id => {
  $(id).addEventListener('input', () => { if (!isPlaying && !isRecording) drawStatic(); });
});

// ─── PNG export ───────────────────────────────────────────────────────────────
$('exportPngBtn').addEventListener('click', () => {
  const out = document.createElement('canvas');
  out.width = W; out.height = H;
  const ctx = out.getContext('2d');
  if (!isTransparent) ctx.drawImage(bgCvs, 0, 0);
  ctx.drawImage(wCvs, 0, 0);
  const a = document.createElement('a');
  a.download = isTransparent ? 'jylabs-waveform-transparent.png' : 'jylabs-waveform.png';
  a.href = out.toDataURL('image/png'); a.click();
  // release PNG canvas immediately
  out.width = 0; out.height = 0;
});

// ─── Video export ─────────────────────────────────────────────────────────────
$('exportVideoBtn').addEventListener('click', () => {
  if (isRecording) { stopRecording(); return; }
  startRecording();
});

function startRecording() {
  if (isPlaying) pauseAudio();

  // Use the DISPLAY canvas directly — no second full-res canvas needed
  // This avoids doubling canvas memory
  const codecs = ['video/webm;codecs=vp9', 'video/webm;codecs=vp8', 'video/webm'];
  const mimeType = codecs.find(c => MediaRecorder.isTypeSupported(c)) || 'video/webm';
  const isVP9 = mimeType.includes('vp9');

  // Capture at display resolution — lower bitrate to prevent OOM
  const stream = wCvs.captureStream(25); // composite both canvases via wCvs overlay approach below
  // Actually we need composite — use a small offscreen canvas at display size only
  const EW = Math.min(W, 960), EH = Math.round(EW * 9/16); // cap at 960px wide
  const exportCanvas = document.createElement('canvas');
  exportCanvas.width = EW; exportCanvas.height = EH;
  const exportCtx = exportCanvas.getContext('2d', { alpha: true, willReadFrequently: false });
  const exportStream = exportCanvas.captureStream(25);

  recordedChunks = [];

  try {
    mediaRecorder = new MediaRecorder(exportStream, {
      mimeType,
      videoBitsPerSecond: 3_000_000  // ← 3Mbps vs previous 10Mbps — much safer
    });
  } catch(e) {
    mediaRecorder = new MediaRecorder(exportStream, { videoBitsPerSecond: 2_000_000 });
  }

  // Flush chunks to array as they arrive
  mediaRecorder.ondataavailable = e => { if (e.data && e.data.size > 0) recordedChunks.push(e.data); };
  mediaRecorder.onstop = () => finaliseVideo(mimeType, isVP9, exportCanvas);
  mediaRecorder.start(500); // ← chunk every 500ms (was 100ms) — less memory pressure

  // Silent audio context for frequency data during render
  recAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
  recAnalyser = recAudioCtx.createAnalyser();
  recAnalyser.fftSize = 1024;
  recAnalyser.smoothingTimeConstant = 0.8;
  const sg = recAudioCtx.createGain(); sg.gain.value = 0;
  recAnalyser.connect(sg); sg.connect(recAudioCtx.destination);

  recFreqData = new Uint8Array(recAnalyser.frequencyBinCount); // allocate once

  recSource = recAudioCtx.createBufferSource();
  recSource.buffer = audioBuffer;
  recSource.connect(recAnalyser);
  recSource.start(0);

  recStartWallTime = recAudioCtx.currentTime;
  isRecording = true;
  updateRecUI(true);

  // Store references for cleanup
  exportCanvas._stream = exportStream;
  renderExportFrame(exportCtx, EW, EH);
}

function renderExportFrame(exportCtx, EW, EH) {
  if (!isRecording) return;

  const elapsed = recAudioCtx.currentTime - recStartWallTime;
  recAnalyser.getByteFrequencyData(recFreqData); // in-place, no allocation

  const color = $('waveColor').value;
  exportCtx.clearRect(0, 0, EW, EH);
  drawBg(exportCtx, EW, EH);
  drawWave(exportCtx, waveDataFull, waveDataFull.length, color, EW, EH, 0.1);
  drawWave(exportCtx, recFreqData, recFreqData.length, color, EW, EH, 1);

  $('progressBar').style.width = (Math.min(elapsed / audioBuffer.duration, 1) * 100) + '%';
  $('currentTime').textContent = formatTime(Math.min(elapsed, audioBuffer.duration));
  $('recTimer').textContent = formatTime(elapsed) + ' / ' + formatTime(audioBuffer.duration);

  if (elapsed >= audioBuffer.duration) {
    stopRecording();
    return;
  }
  recAF = requestAnimationFrame(() => renderExportFrame(exportCtx, EW, EH));
}

function stopRecording() {
  isRecording = false;
  cancelAnimationFrame(recAF); recAF = null;
  try { recSource && recSource.stop(); } catch(e){}
  try { recAudioCtx && recAudioCtx.close(); } catch(e){}
  recAudioCtx = null; recAnalyser = null; recSource = null; recFreqData = null;
  try { if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop(); } catch(e){}
  updateRecUI(false);
  drawStatic();
  $('progressBar').style.width = '0%';
  $('currentTime').textContent = '0:00';
}

function updateRecUI(rec) {
  $('recStatus').classList.toggle('active', rec);
  $('playBtn').disabled = rec; $('exportPngBtn').disabled = rec; $('resetBtn').disabled = rec;
  const btn = $('exportVideoBtn');
  if (rec) {
    btn.textContent = 'Stop & Save'; btn.className = 'btn btn-stop';
    $('recLabel').textContent = isTransparent ? 'Rendering transparent WebM…' : 'Rendering video…';
  } else {
    btn.textContent = 'Export Video'; btn.className = 'btn btn-primary';
  }
}

function finaliseVideo(mimeType, isVP9, exportCanvas) {
  // Release the export canvas memory
  exportCanvas.width = 0; exportCanvas.height = 0;

  const blob = new Blob(recordedChunks, { type: mimeType || 'video/webm' });
  recordedChunks = []; // free chunk memory immediately

  const url = URL.createObjectURL(blob);
  const fname = isTransparent ? 'jylabs-waveform-transparent.webm' : 'jylabs-waveform.webm';
  const a = document.createElement('a'); a.href = url; a.download = fname; a.click();
  setTimeout(() => URL.revokeObjectURL(url), 10000);

  if (isTransparent) {
    toast('<b>Saved: jylabs-waveform-transparent.webm</b><br>Premiere → drag above footage → blend: Normal<br>After Effects → Interpret Alpha: Straight', 8000);
  } else {
    toast('<b>Saved: jylabs-waveform.webm</b>', 4000);
  }
}

// ─── Reset ────────────────────────────────────────────────────────────────────
$('resetBtn').addEventListener('click', () => {
  if (isRecording) stopRecording();
  cleanup();
  isVideoSource = false;
  $('workspace').style.display = 'none';
  $('workspace').classList.remove('visible');
  $('uploadSection').style.display = 'flex';
  fileInput.value = '';
  $('transparentToggle').checked = false;
  applyTransparent(false);
  $('videoNote').classList.remove('show');
  $('canvasWrap').classList.add('has-bg');
  $('progressBar').style.width = '0%';
  $('currentTime').textContent = '0:00';
});

// ─── Colour helpers ───────────────────────────────────────────────────────────
function shiftHue(hex, deg) {
  const [r,g,b] = hexToRgb(hex), [h,s,l] = rgbToHsl(r,g,b);
  const [r2,g2,b2] = hslToRgb((h+deg/360)%1,s,l);
  return `rgb(${r2},${g2},${b2})`;
}
function lighten(hex, amt) {
  const [r,g,b] = hexToRgb(hex);
  return `rgb(${Math.min(255,(r+amt*255)|0)},${Math.min(255,(g+amt*255)|0)},${Math.min(255,(b+amt*255)|0)})`;
}
function hexToRgb(h){return[parseInt(h.slice(1,3),16),parseInt(h.slice(3,5),16),parseInt(h.slice(5,7),16)];}
function rgbToHsl(r,g,b){r/=255;g/=255;b/=255;const mx=Math.max(r,g,b),mn=Math.min(r,g,b);let h,s,l=(mx+mn)/2;if(mx===mn){h=s=0;}else{const d=mx-mn;s=l>.5?d/(2-mx-mn):d/(mx+mn);switch(mx){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;default:h=(r-g)/d+4;}h/=6;}return[h,s,l];}
function hslToRgb(h,s,l){if(!s)return[l*255,l*255,l*255].map(Math.round);const q=l<.5?l*(1+s):l+s-l*s,p=2*l-q,f=(p,q,t)=>{t<0&&(t+=1);t>1&&(t-=1);return t<1/6?p+(q-p)*6*t:t<.5?q:t<2/3?p+(q-p)*(2/3-t)*6:p;};return[f(p,q,h+1/3),f(p,q,h),f(p,q,h-1/3)].map(v=>Math.round(v*255));}
function formatTime(s){s=Math.max(0,s);return`${Math.floor(s/60)}:${String(Math.floor(s%60)).padStart(2,'0')}`;}

function toast(html, duration=5000){
  const t=document.createElement('div'); t.className='toast'; t.innerHTML=html;
  document.body.appendChild(t);
  setTimeout(()=>{t.style.opacity='0';setTimeout(()=>t.remove(),600);},duration);
}
</script>
</body>
</html>
